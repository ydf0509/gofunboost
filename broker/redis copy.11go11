package broker

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/go-redis/redis/v8"
	"golang.org/x/time/rate"
)

// 定义错误
var (
	ErrUnsupportedBrokerType = errors.New("unsupported broker type")
	ErrInvalidConsumeFunc    = errors.New("invalid consume function")
	ErrRedisConnection       = errors.New("redis connection error")
)



// RedisAcker 实现Acker接口
type RedisAcker struct {
	Client *redis.Client
	ID     string
	Queue  string
}

// Ack 确认消息已处理
func (a *RedisAcker) Ack() error {
	return nil // Redis使用LPOP，不需要显式确认
}

// Nack 拒绝消息
func (a *RedisAcker) Nack() error {
	ctx := context.Background()
	// 将消息重新放回队列
	msg, err := a.Client.Get(ctx, a.ID).Result()
	if err != nil {
		return err
	}
	_, err = a.Client.RPush(ctx, a.Queue, msg).Result()
	return err
}

// RedisBroker 实现Redis消息队列
type RedisBroker struct {
	*Broker
	clients []*redis.Client
	limiter *rate.Limiter
}

// NewRedisBroker 创建Redis Broker
func NewRedisBroker(broker *Broker) (BaseBroker, error) {
	if broker.QueueName == "" {
		return nil, errors.New("queue name is required")
	}

	if broker.ConsumeFunc == nil {
		return nil, ErrInvalidConsumeFunc
	}

	// 创建QPS限制器
	var limiter *rate.Limiter
	if broker.QPSLimit > 0 {
		limiter = rate.NewLimiter(rate.Limit(broker.QPSLimit), broker.QPSLimit)
	}

	return &RedisBroker{
		Broker:  broker,
		clients: make([]*redis.Client, 0, broker.ConnNum),
		limiter: limiter,
	}, nil
}

// createRedisClient 创建Redis客户端
func (r *RedisBroker) createRedisClient() (*redis.Client, error) {
	options, err := r.parseRedisOptions()
	if err != nil {
		return nil, err
	}

	client := redis.NewClient(options)
	// 测试连接
	ctx := context.Background()
	if _, err := client.Ping(ctx).Result(); err != nil {
		return nil, err
	}

	return client, nil
}

// parseRedisOptions 解析Redis配置选项
func (r *RedisBroker) parseRedisOptions() (*redis.Options, error) {
	options := &redis.Options{
		Addr: r.BrokerConfig.BrokerUrl,
	}

	// 处理额外的配置选项
	if r.BrokerConfig.BrokerTransportOptions != nil {
		if password, ok := r.BrokerConfig.BrokerTransportOptions["password"].(string); ok {
			options.Password = password
		}

		if db, ok := r.BrokerConfig.BrokerTransportOptions["db"].(int); ok {
			options.DB = db
		}

		if maxRetries, ok := r.BrokerConfig.BrokerTransportOptions["max_retries"].(int); ok {
			options.MaxRetries = maxRetries
		}

		if minIdleConns, ok := r.BrokerConfig.BrokerTransportOptions["min_idle_conns"].(int); ok {
			options.MinIdleConns = minIdleConns
		}
	}

	return options, nil
}

// Consume 实现消费逻辑
func (r *RedisBroker) Consume() error {
	r.Logger.Info("Starting Redis consumer",
		zap.String("queue", r.QueueName),
		zap.Int("conn_num", r.ConnNum),
		zap.Int("concurrent_num", r.ConcurrentNum))

	// 创建多个连接进行消费
	for i := 0; i < r.ConnNum; i++ {
		go func(connID int) {
			r.Logger.Info("Starting consumer connection", zap.Int("conn_id", connID))
			for {
				ctx := context.Background()
				err := r.ConsumeUsingOneConn(ctx)
				if err != nil {
					r.Logger.Error("Consumer connection failed",
						zap.Int("conn_id", connID),
						zap.Error(err))
					// 等待一段时间后重试
					time.Sleep(60 * time.Second)
				}
			}
		}(i)
	}

	return nil
}

// ConsumeUsingOneConn 使用一个连接消费消息
func (r *RedisBroker) ConsumeUsingOneConn(ctx context.Context) error {
	// 创建Redis客户端
	client, err := r.createRedisClient()
	if err != nil {
		return fmt.Errorf("failed to create Redis client: %w", err)
	}
	defer client.Close()

	r.Logger.Info("Redis connection established", zap.String("addr", client.Options().Addr))

	// 持续消费消息
	for {
		// 检查上下文是否已取消
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
			// 继续执行
		}

		// 如果设置了QPS限制，则等待令牌
		if r.limiter != nil {
			r.limiter.Wait(ctx)
		}

		// 从队列中获取消息
		result, err := client.LPop(ctx, r.QueueName).Result()
		if err != nil {
			if err == redis.Nil {
				// 队列为空，等待一段时间后重试
				time.Sleep(100 * time.Millisecond)
				continue
			}
			r.Logger.Error("Failed to get message from Redis", zap.Error(err))
			return err
		}

		// 解析消息
		var message RedisMessage
		if err := json.Unmarshal([]byte(result), &message); err != nil {
			r.Logger.Error("Failed to unmarshal message", zap.Error(err), zap.String("message", result))
			continue
		}

		// 创建Acker
		acker := &RedisAcker{
			Client: client,
			ID:     fmt.Sprintf("%s:%s", r.QueueName, time.Now().String()),
			Queue:  r.QueueName,
		}

		// 提交任务到协程池
		r.Pool.Submit(func() {
			r.processMessage(message.Args, acker)
		})
	}
}

// processMessage 处理消息
func (r *RedisBroker) processMessage(args []interface{}, acker Acker) {
	// 在这里调用用户提供的消费函数
	// 使用反射调用函数，并传入参数
	// 这部分需要根据实际情况实现
	// ...

	// 确认消息已处理
	if err := acker.Ack(); err != nil {
		r.Logger.Error("Failed to ack message", zap.Error(err))
	}
}

// Push 推送消息到队列
func (r *RedisBroker) Push(args ...interface{}) error {
	// 创建Redis客户端
	client, err := r.createRedisClient()
	if err != nil {
		return fmt.Errorf("failed to create Redis client: %w", err)
	}
	defer client.Close()

	// 创建消息
	message := RedisMessage{
		Args: args,
	}

	// 序列化消息
	data, err := json.Marshal(message)
	if err != nil {
		return fmt.Errorf("failed to marshal message: %w", err)
	}

	// 重试逻辑
	var lastErr error
	for i := 0; i < r.MaxRetries; i++ {
		ctx := context.Background()
		_, err = client.RPush(ctx, r.QueueName, data).Result()
		if err == nil {
			return nil
		}

		lastErr = err
		r.Logger.Warn("Failed to push message to Redis, retrying",
			zap.Error(err),
			zap.Int("attempt", i+1),
			zap.Int("max_retries", r.MaxRetries))

		// 等待一段时间后重试
		time.Sleep(5 * time.Second)

		// 尝试重新创建客户端
		client.Close()
		client, err = r.createRedisClient()
		if err != nil {
			r.Logger.Error("Failed to recreate Redis client", zap.Error(err))
			continue
		}
	}

	r.Logger.Error("Failed to push message to Redis after retries",
		zap.Error(lastErr),
		zap.Int("max_retries", r.MaxRetries))

	return fmt.Errorf("failed to push message after %d retries: %w", r.MaxRetries, lastErr)
}

// Close 关闭Broker
func (r *RedisBroker) Close() error {
	// 关闭所有Redis客户端
	for _, client := range r.clients {
		if client != nil {
			client.Close()
		}
	}

	return nil
}
